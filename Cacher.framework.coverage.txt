/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Cache/CacheTypes/CacheType.swift:
    1|       |//
    2|       |//  CacheType.swift
    3|       |//  CacherTests
    4|       |//
    5|       |//  Created by Aashish Tamsya on 24/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public enum CacheType {
   12|       |  case none
   13|       |  case memory
   14|       |  case disk
   15|       |  
   16|      0|  public var isCached: Bool {
   17|      0|    switch self {
   18|      0|    case .memory, .disk: return true
   19|      0|    case .none: return false
   20|      0|    }
   21|      0|  }
   22|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Cache/CacheTypes/DiskCache.swift:
    1|       |//
    2|       |//  DiskCache.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 27/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |final internal class DiskCache: DiskCachable {
   12|       |  
   13|      1|  public let path: String = {
   14|      1|    let destinationPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first!
   15|      1|    return (destinationPath as NSString).appendingPathComponent("CacherDiskCache")
   16|      1|  }()
   17|       |  
   18|       |  fileprivate let fileManager = FileManager()
   19|       |  fileprivate let ioQueue: DispatchQueue = DispatchQueue(label: "CacherDiskCacheIOQueue")
   20|       |  
   21|      0|  func store<T>(key: String, object: T, _ completion: (() -> Void)?) where T: Cachable {
   22|      0|    ioQueue.async {
   23|      0|      if !self.fileManager.fileExists(atPath: self.path) {
   24|      0|        do {
   25|      0|          try self.fileManager.createDirectory(atPath: self.path, withIntermediateDirectories: true, attributes: nil)
   26|      0|        } catch _ {
   27|      0|          
   28|      0|        }
   29|      0|      }
   30|      0|      
   31|      0|      let cacheFilePath = (self.path as NSString).appendingPathComponent(key)
   32|      0|      self.fileManager.createFile(atPath: cacheFilePath, contents: object.encode(), attributes: nil)
   33|      0|      completion?()
   34|      0|    }
   35|      0|  }
   36|       |  
   37|      0|  func retrieve<T>(key: String, _ completion: @escaping (T?) -> Void) where T: Cachable {
   38|      0|    let filePath = (self.path as NSString).appendingPathComponent(key)
   39|      0|    let object = try? Data(contentsOf: URL(fileURLWithPath: filePath))
   40|      0|    completion(object as? T)
   41|      0|  }
   42|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Cache/CacheTypes/MemoryCache.swift:
    1|       |//
    2|       |//  MemoryCache.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 24/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |final internal class MemoryCache: MemoryCachable {
   12|       |  private let cache = NSCache<AnyObject, AnyObject>()
   13|       |
   14|      0|  func store<T>(key: String, object: T, _ completion: (() -> Void)?) where T: Cachable {
   15|      0|    cache.setObject(object as AnyObject, forKey: key as AnyObject)
   16|      0|    completion?()
   17|      0|  }
   18|       |  
   19|      1|  func retrieve<T>(key: String, _ completion: @escaping (T?) -> Void) where T: Cachable {
   20|      1|    let object = cache.object(forKey: key as AnyObject)
   21|      1|    completion(object as? T)
   22|      1|  }
   23|       |
   24|      0|  func removeAll() {
   25|      0|    cache.removeAllObjects()
   26|      0|  }
   27|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Cache/Cacher.swift:
    1|       |//
    2|       |//  Cacher.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 24/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |private var taskPool: [URLSessionDataTask: URL] = [:]
   12|       |
   13|       |public class Cacher {
   14|       |  public static let sharedCache = Cacher()
   15|       |  
   16|       |  private let memoryCache = MemoryCache()
   17|       |  private let diskCache = DiskCache()
   18|       |  private var session: URLSession
   19|       |  
   20|      1|  init() {
   21|      1|    session = URLSession(configuration: .default)
   22|      1|  }
   23|       |}
   24|       |// MARK: - Cache
   25|       |extension Cacher: Cache {
   26|      0|  public func store<T>(_ setting: (to: CacheType, key: String), object: T, _ completion: (() -> Void)?) where T: Cachable {
   27|      0|    switch setting.to {
   28|      0|    case .disk:
   29|      0|      diskCache.store(key: setting.key, object: object, completion)
   30|      0|    case .memory:
   31|      0|      memoryCache.store(key: setting.key, object: object, completion)
   32|      0|    case .none:
   33|      0|      completion?()
   34|      0|    }
   35|      0|  }
   36|       |  
   37|      0|  public func retrieve<T>(from: CacheType, key: String, _ completion: @escaping (T?) -> Void) where T: Cachable {
   38|      0|    switch from {
   39|      0|    case .disk:
   40|      0|      diskCache.retrieve(key: key, completion)
   41|      0|    case .memory:
   42|      0|      memoryCache.retrieve(key: key, completion)
   43|      0|    case .none:
   44|      0|      completion(nil)
   45|      0|    }
   46|      0|  }
   47|       |  
   48|      0|  public func removeAll() {
   49|      0|    memoryCache.removeAll()
   50|      0|    taskPool.removeAll()
   51|      0|  }
   52|       |}
   53|       |// MARK: - Downloadable
   54|       |extension Cacher: Downloadable {
   55|      1|  public func download<T>(cacheType type: CacheType, url: URL, completion: @escaping (T?, CacheType) -> Void) -> CancelToken? where T: Cachable {
   56|      1|    guard let key = url.key else {
   57|      0|      completion(nil, .none)
   58|      0|      return nil
   59|      1|    }
   60|      1|    var token: CancelToken?
   61|      1|    switch type {
   62|      1|    case .none:
   63|      0|      return nil
   64|      1|    case .disk:
   65|      0|      diskCache.retrieve(key: key) { [weak self] (object: Data?) in
   66|      0|        token = self?.process(retrievedObject: object, configuration: (url, .disk), completion)
   67|      0|      }
   68|      1|    case .memory:
   69|      1|      memoryCache.retrieve(key: key) { [weak self] (object: Data?) in
   70|      1|        token = self?.process(retrievedObject: object, configuration: (url, .memory), completion)
   71|      1|      }
   72|      1|    }
   73|      1|    return token
   74|      1|  }
   75|       |  
   76|      0|  public func cancel(_ url: URL, token: CancelToken? = nil) -> Bool {
   77|      0|    guard let task = token?.task, let cancelToken = taskPool.filter({ $0.key == task && $0.value == url }).first?.key else { return false }
   78|      0|    cancelToken.cancel()
   79|      0|    taskPool.removeValue(forKey: cancelToken)
   80|      0|    return true
   81|      0|  }
   82|       |}
   83|       |// MARK: - Private Methods
   84|       |private extension Cacher {
   85|      1|  func process<T>(retrievedObject object: Data?, configuration: (url: URL, type: CacheType), _ completion: @escaping (T?, CacheType) -> Void) -> CancelToken? where T: Cachable {
   86|      1|    guard object == nil else {
   87|      0|      completion(object as? T, configuration.type)
   88|      0|      return nil
   89|      1|    }
   90|      1|    let task = self.session.dataTask(with: configuration.url) { [weak self] data, _, _ in
   91|      1|      self?.storeInCache(CacheSettings(type: configuration.type, url: configuration.url, object: data, image: nil), completion)
   92|      1|    }
   93|      1|    task.resume()
   94|      1|    taskPool[task] = configuration.url
   95|      1|    return CancelToken(task)
   96|      1|  }
   97|       |  
   98|      0|  func storeInCache<T>(_ settings: CacheSettings?, _ completion: @escaping (T?, CacheType) -> Void) where T: Cachable {
   99|      0|    guard let data = settings?.object, let key = settings?.url?.key, let type = settings?.type else {
  100|      0|      completion(nil, .none)
  101|      0|      return
  102|      0|    }
  103|      0|    switch type {
  104|      0|    case .disk:
  105|      0|      diskCache.store(key: key, object: data) { completion(data as? T, .none) }
  106|      0|    case .memory:
  107|      0|      memoryCache.store(key: key, object: data) { completion(data as? T, .none) }
  108|      0|    case .none:
  109|      0|      completion(data as? T, .none)
  110|      0|    }
  111|      0|  }
  112|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Network/CancelToken.swift:
    1|       |//
    2|       |//  CacnelToken.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 26/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public class CancelToken: Hashable {
   12|       |  weak var task: URLSessionDataTask?
   13|       |  
   14|      1|  public func hash(into hasher: inout Hasher) {
   15|      1|    hasher.combine(task.hashValue)
   16|      1|  }
   17|       |  
   18|      1|  init(_ task: URLSessionDataTask) {
   19|      1|    self.task = task
   20|      1|  }
   21|       |  
   22|      0|  func cancel() -> Bool {
   23|      0|    guard let task = task else { return false }
   24|      0|    task.cancel()
   25|      0|    return true
   26|      0|  }
   27|       |}
   28|       |extension CancelToken: Equatable {
   29|      0|  public static func == (lhs: CancelToken, rhs: CancelToken) -> Bool {
   30|      0|    return lhs.hashValue == rhs.hashValue
   31|      0|  }
   32|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Shared/Extensions/Data+Cache.swift:
    1|       |//
    2|       |//  Data+Cache.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 24/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Data: Cachable {
   12|       |  public typealias T = Data
   13|       |
   14|      0|  public static func decode(_ data: Data) -> Data? {
   15|      0|    return data
   16|      0|  }
   17|       |  
   18|      0|  public func encode() -> Data? {
   19|      0|    return self
   20|      0|  }
   21|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Shared/Extensions/UIImage+Cache.swift:
    1|       |//
    2|       |//  UIImage+Cache.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 24/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |extension UIImage: Cachable {
   12|       |  public typealias T = UIImage
   13|       |  
   14|      0|  public static func decode(_ data: Data) -> UIImage? {
   15|      0|    let image = UIImage(data: data)
   16|      0|    return image
   17|      0|  }
   18|       |  
   19|      0|  public func encode() -> Data? {
   20|      0|    return hasAlpha ? pngData() : jpegData(compressionQuality: 1.0)
   21|      0|  }
   22|       |}
   23|       |
   24|       |extension UIImage {
   25|      0|  var hasAlpha: Bool {
   26|      0|    var result = false
   27|      0|    guard let alpha = cgImage?.alphaInfo else { return false }
   28|      0|    switch alpha {
   29|      0|    case .none, .noneSkipLast, .noneSkipFirst:
   30|      0|      result = false
   31|      0|    case .premultipliedLast, .premultipliedFirst, .last, .first, .alphaOnly:
   32|      0|      result = true
   33|      0|    @unknown default:
   34|      0|      result = false
   35|      0|    }
   36|      0|    return result
   37|      0|  }
   38|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Shared/Extensions/UIImageView+Cache.swift:
    1|       |//
    2|       |//  UIImageView+Cache.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 24/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension UIImageView {
   12|      0|  public func loadImage(withURL url: URL, placeholder: UIImage? = nil, transition: ImageTransition? = .none, completion: ((UIImage?) -> Void)? = nil) -> CancelToken? {
   13|      0|    let cache = Cacher.sharedCache
   14|      0|    let token = cache.download(cacheType: .memory, url: url) { (object: Data?, cacheType: CacheType) in
   15|      0|      if let data = object, let image = UIImage(data: data) {
   16|      0|        guard self.requiresTransition(transition: transition ?? .none, cacheType: cacheType) else {
   17|      0|          DispatchQueue.main.async {
   18|      0|            self.image = image
   19|      0|            completion?(image)
   20|      0|          }
   21|      0|          return
   22|      0|        }
   23|      0|        if let transition = transition {
   24|      0|          self.performTransition(image: image, transition: transition, done: {
   25|      0|            completion?(image)
   26|      0|          })
   27|      0|        } else {
   28|      0|          DispatchQueue.main.async {
   29|      0|            self.image = image
   30|      0|            completion?(image)
   31|      0|          }
   32|      0|        }
   33|      0|      } else {
   34|      0|        DispatchQueue.main.async {
   35|      0|          self.image = placeholder
   36|      0|          completion?(nil)
   37|      0|        }
   38|      0|      }
   39|      0|    }
   40|      0|    return token
   41|      0|  }
   42|       |  
   43|      0|  private func requiresTransition(transition: ImageTransition, cacheType: CacheType) -> Bool {
   44|      0|    switch transition {
   45|      0|    case .none:
   46|      0|      return false
   47|      0|    case .fade:
   48|      0|      if cacheType == .none { return true }
   49|      0|      return false
   50|      0|    }
   51|      0|  }
   52|       |  
   53|      0|  private func performTransition(image: UIImage, transition: ImageTransition, done: @escaping () -> Void) {
   54|      0|    UIView.transition(with: self, duration: transition.duration, options: [transition.animationOptions, .allowUserInteraction], animations: {
   55|      0|      DispatchQueue.main.async {
   56|      0|        self.image = image
   57|      0|      }
   58|      0|    }, completion: { _ in
   59|      0|      DispatchQueue.main.async {
   60|      0|        done()
   61|      0|      }
   62|      0|    })
   63|      0|  }
   64|       |  
   65|      0|  public func cancelImageLoading(_ url: URL, cancelToken: CancelToken? = nil) -> Bool {
   66|      0|    return Cacher.sharedCache.cancel(url, token: cancelToken)
   67|      0|  }
   68|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Shared/Extensions/URL+Extensions.swift:
    1|       |//
    2|       |//  URL+Extensions.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 27/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension URL {
   12|      1|  public var key: String? { get { return pathComponents.last } }
   13|       |}

/Users/aashish.tamsya/Desktop/MindValley-Challenge/Sources/Shared/Image/ImageTransition.swift:
    1|       |//
    2|       |//  ImageTransition.swift
    3|       |//  Cacher
    4|       |//
    5|       |//  Created by Aashish Tamsya on 24/06/19.
    6|       |//  Copyright © 2019 Aashish Tamsya. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public enum ImageTransition {
   12|       |  case none
   13|       |  case fade(TimeInterval)
   14|       |  
   15|      0|  var duration: TimeInterval {
   16|      0|    switch self {
   17|      0|    case .fade(let duration):
   18|      0|      return duration
   19|      0|    case .none:
   20|      0|      return 0
   21|      0|    }
   22|      0|  }
   23|       |  
   24|      0|  var animationOptions: UIView.AnimationOptions {
   25|      0|    switch self {
   26|      0|    case .fade: return .transitionCrossDissolve
   27|      0|    case .none: return []
   28|      0|    }
   29|      0|  }
   30|       |}

